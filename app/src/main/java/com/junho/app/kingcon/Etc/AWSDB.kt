@file:Suppress("DEPRECATION")package com.junho.app.kingcon.Etcimport android.annotation.SuppressLintimport android.content.Contextimport android.os.StrictModeimport android.util.Logimport android.widget.Toastimport com.amazonaws.AmazonServiceExceptionimport com.amazonaws.ClientConfigurationimport com.amazonaws.mobile.auth.core.internal.util.ThreadUtilsimport com.amazonaws.mobile.client.AWSMobileClientimport com.amazonaws.mobileconnectors.dynamodbv2.dynamodbmapper.DynamoDBMapperimport com.amazonaws.mobileconnectors.dynamodbv2.dynamodbmapper.DynamoDBQueryExpressionimport com.amazonaws.regions.Regionimport com.amazonaws.regions.Regionsimport com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientimport com.amazonaws.services.dynamodbv2.model.*import com.junho.app.kingcon.Etc.CallBack.CallbackAWSDBimport com.junho.app.kingcon.Etc.StringData.CONDOM_MAX_NUMimport com.junho.app.kingcon.Etc.StringData.CONDOM_TYPEimport com.junho.app.kingcon.Etc.StringData.DB_COMPANYimport com.junho.app.kingcon.Etc.StringData.DB_FEMALE_GRAPHimport com.junho.app.kingcon.Etc.StringData.DB_GRAPHimport com.junho.app.kingcon.Etc.StringData.DB_IDimport com.junho.app.kingcon.Etc.StringData.DB_INFOimport com.junho.app.kingcon.Etc.StringData.DB_MALEGRAPHimport com.junho.app.kingcon.Etc.StringData.DB_NAMEimport com.junho.app.kingcon.Etc.StringData.DB_PICTUREimport com.junho.app.kingcon.Etc.StringData.DB_POINTimport com.junho.app.kingcon.Etc.StringData.DB_RATINGimport com.junho.app.kingcon.Etc.StringData.DB_REVIEWimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_CONTENTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_DATAimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_DATEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_IDimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_LIKEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_LIKE_LISTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_CONTENTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_DATEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_IDimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_LIKEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_LIKE_LISTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_POINTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_USER_IDimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_WISHimport com.junho.app.kingcon.Etc.StringData.DB_TAGimport com.junho.app.kingcon.Etc.StringData.DB_TOTALPOINTimport com.junho.app.kingcon.Etc.StringData.DB_TYPEimport com.junho.app.kingcon.Etc.StringData.DB_USER_AGEimport com.junho.app.kingcon.Etc.StringData.DB_USER_GENDERimport com.junho.app.kingcon.Etc.StringData.DB_USER_IDimport com.junho.app.kingcon.Etc.StringData.DB_USER_NAMEimport com.junho.app.kingcon.Etc.StringData.DB_USER_PICTUREimport com.junho.app.kingcon.Etc.StringData.DB_USER_REVIEWimport com.junho.app.kingcon.Etc.StringData.DB_WISHimport com.junho.app.kingcon.Etc.StringData.PRODUCT_INIT_NUMimport com.junho.app.kingcon.Etc.StringData.PRODUCT_TABLEimport com.junho.app.kingcon.Etc.StringData.REVIEW_INDEX_LIKEimport com.junho.app.kingcon.Etc.StringData.REVIEW_TABLEimport com.junho.app.kingcon.Etc.StringData.USER_TABLEimport com.junho.app.kingcon.Etc.StringData.userDataimport com.junho.app.kingcon.Item.*import java.io.Fileimport java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashMapimport kotlin.concurrent.threadobject AWSDB {    private var client: AmazonDynamoDBClient? = null    private lateinit var dynamoDBMapper: DynamoDBMapper    private lateinit var dynamoDb: AmazonDynamoDBClient    fun init() {        client = Region.getRegion(Regions.AP_NORTHEAST_2) // CRUCIAL            .createClient(                AmazonDynamoDBClient::class.java,                AWSMobileClient.getInstance().credentialsProvider,                ClientConfiguration()            )        dynamoDBMapper = DynamoDBMapper.builder()            .dynamoDBClient(client)            .awsConfiguration(AWSMobileClient.getInstance().configuration)            .build()        dynamoDb = AmazonDynamoDBClient(            AWSMobileClient.getInstance().credentialsProvider,            ClientConfiguration()        )    }    //공급자로 유저 이미 가입했는지 확인    fun isSignUp(callBack: CallbackAWSDB.Login){        ThreadUtils.runOnUiThread {            networkThread() //네트워크 사용 쓰레드            val userData = UserData()            userData.id = User.id            val queryExpression = DynamoDBQueryExpression<UserData>()                .withHashKeyValues(userData)                .withLimit(1)            val a = dynamoDBMapper.queryPage(UserData::class.java, queryExpression).results            //TODO 쿼리페이지로 1개만 가져오기 했을때 데이터 없으면 어떻게되는지 확인            when {//                아이디 서버등록 + 정보입력 둘다 안함                a.size == 0 -> callBack.isUserSignUp(id = false, info = false)//                정보입력만 안함                a[0].age == 0L -> {                    User.setUser(a[0])                    callBack.isUserSignUp(id = true, info = false)                }//                 둘다 함                else -> {                    User.setUser(a[0])                    callBack.isUserSignUp(id = true, info = true)                }            }        }    }    //유저 정보 저장    fun createUserBasicAttr(userData: UserData){        thread {            dynamoDBMapper.save(userData)        }    }    //유저 정보 저장    fun createUserAddAttr(userData: UserProfileData){        thread {            dynamoDBMapper.save(userData)        }    }    fun readUserAttr() {        thread {            val data = UserData()            data.id = User.id            val queryExpression = DynamoDBQueryExpression<UserData>()                .withHashKeyValues(data)                .withLimit(1)                .withScanIndexForward(false)            User.setUser(dynamoDBMapper.queryPage(UserData::class.java, queryExpression).results[0])            User.localUserDataUpdate()        }    }    fun readUserTagData(){        thread {            val data = UserPreferData()            data.id = User.id            val queryExpression = DynamoDBQueryExpression<UserPreferData>()                .withHashKeyValues(data)                .withLimit(1)                .withScanIndexForward(false)            User.setUserPreferTag(dynamoDBMapper.queryPage(UserPreferData::class.java, queryExpression).results[0])            User.localUserDataUpdate()        }    }    fun updateUserAttr(userData: UserData){        thread {            dynamoDBMapper.save(userData)        }    }    fun userTagUpdate(tag: ArrayList<String>, point: Int){        thread {            User.localUserDataRead(File(userData()))            val attrName = hashMapOf<String, String>()            val attrValue = hashMapOf<String, AttributeValue>()            val tagList = HashMap<String, AttributeValue>()            var updateExpression = "SET "            var i = 1            tag.forEach {                if(User.preferTag[it] == null)                    User.preferTag[it] = point                else                    User.preferTag[it] = User.preferTag[it]!! + (point)                attrName["#n$i"] = it                attrValue[":m$i"] = AttributeValue().withN(User.preferTag[it].toString())                tagList[it] = AttributeValue().withN(User.preferTag[it].toString())                updateExpression += "PreferTag.#n$i = :m$i,"                i++            }            updateExpression = updateExpression.removeRange(updateExpression.lastIndex, updateExpression.lastIndex+1)            User.localUserDataUpdate()            //로컬 데이터 저장까진 됐고 서버에 저장하는거 낱개로            try {                //서버에 리스트 있을때                client?.updateItem(                    UpdateItemRequest()                        .withTableName(USER_TABLE)                        .withKey(hashMapOf("Id" to AttributeValue().withS(User.id)))                        .withUpdateExpression(updateExpression)                        .withExpressionAttributeNames(attrName)                        .withExpressionAttributeValues(attrValue)                )            }catch (e: AmazonServiceException){                //서버에 리스트 없을떄                client?.updateItem(                    UpdateItemRequest()                        .withTableName(USER_TABLE)                        .withKey(hashMapOf("Id" to AttributeValue().withS(User.id)))                        .withUpdateExpression("SET PreferTag = :m1")                        .withExpressionAttributeValues(hashMapOf(":m1" to AttributeValue().withM(tagList)))                )            }        }    }    ///////////////////////////////////////////////    //태그 버전 체크 및 최신 데이터 가져오    fun tagVersionCheck(callBack: CallbackAWSDB.Tag){        networkThread() //네트워크 사용 쓰레드        val tagVersion = TagVersion()        val queryExpression = DynamoDBQueryExpression<TagVersion>()            .withHashKeyValues(tagVersion)            .withLimit(1)            .withScanIndexForward(false)        //버전 데이터        AppData.loadAppData()        val newVersion = dynamoDBMapper.queryPage(TagVersion::class.java, queryExpression).results[0].version        val oldVersion = AppData.getTagVersion()        //버전 그대로        if((oldVersion == newVersion)) {            callBack.callbackTagData(AppData.getTagData())        }        //최신 태그 데이터 가져오기        else{            val tagData = TagData()            val query = DynamoDBQueryExpression<TagData>()                .withHashKeyValues(tagData)                .withLimit(1)                .withScanIndexForward(false)            val data = dynamoDBMapper.queryPage(TagData::class.java, query).results[0]            AppData.putTagData(data)            AppData.putTagVersion(newVersion!!)            AppData.updateAppData()            callBack.callbackTagData(data)        }    }    //////////////////////////제품데이터 생성    /** 제품데이터 저장 */    fun createProduct(context: Context, product: ProductData) {        thread {            try {                dynamoDBMapper.save(product)                ThreadUtils.runOnUiThread {                    Toast.makeText(context,"업로드 완료",Toast.LENGTH_SHORT).show()                }            }catch (e:Exception){                Log.e("product upload error",e.toString())                ThreadUtils.runOnUiThread {                    Toast.makeText(context,"업로드 실패 $e",Toast.LENGTH_SHORT).show()                }            }        }    }    /** 제품 홈 리스트 가져오기 (랜덤 -> 추천) */    fun readProduct(type: String, productData: ArrayList<ProductData>) {        val keyConditions = java.util.HashMap<String, Condition>()        keyConditions[DB_TYPE] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(type))        //가져올 제품 랜덤으로 뽑기        val rnd = Random()        val overload = arrayListOf<Int>()        val batchGetItemRequest = BatchGetItemRequest()        val requestItems = HashMap<String, KeysAndAttributes>()     //        val tableKeys = ArrayList<Map<String, AttributeValue>>()    //        var key: MutableMap<String, AttributeValue>     ////        키값 중복 안되도록 저장        for(i in 1 .. PRODUCT_INIT_NUM) {            var n = (rnd.nextInt(CONDOM_MAX_NUM)+ 1001)            //중복 데이터 체크            while(overload.indexOf(n) != -1) { n = (rnd.nextInt(CONDOM_MAX_NUM) + 1001) }            overload.add(n)            key = HashMap()            key[DB_TYPE] = AttributeValue().withS(CONDOM_TYPE)            key[DB_ID] = AttributeValue().withS((n.toString()))            tableKeys.add(key)        }        requestItems[PRODUCT_TABLE] = KeysAndAttributes().withKeys(tableKeys)            .withProjectionExpression("#id, #c, #n, #t, #p, #review, #rating, #wish")            .withExpressionAttributeNames(mapOf("#id" to DB_ID, "#n" to DB_NAME, "#c" to DB_COMPANY,  "#t" to DB_TAG,  "#p" to DB_POINT,                "#rating" to DB_RATING, "#wish" to DB_WISH, "#review" to DB_REVIEW))//예약어 쓸 때 주의        batchGetItemRequest.withRequestItems(requestItems)        val result = client?.batchGetItem(batchGetItemRequest)!!.responses[PRODUCT_TABLE]        for(j in 0 until overload.size)            for(i in 0 until result!!.size){                if(result[i][DB_ID]?.s.toString() == overload[j].toString()){                    val tag = arrayListOf<String>()                    result[i][DB_TAG]?.l?.forEach { tag.add(it.s.toString()) }                    productData.add(ProductData(ProductHomeList(type, result[i][DB_ID]?.s.toString(), result[i][DB_NAME]?.s.toString(),                        result[i][DB_PICTURE]?.s.toString(), result[i][DB_COMPANY]?.s.toString(), tag, result[i][DB_POINT]?.n!!.toFloat(),                        result[i][DB_RATING]?.n!!.toInt(), result[i][DB_WISH]?.n!!.toInt(), result[i][DB_REVIEW]?.n!!.toInt())))                }            }    }    /** 리뷰 올린 유저 데이터 */    private fun readReviewUser(userData: ArrayList<ReviewData>){        //베댓 유저 정보        if(userData.size !=0){            val batchGetItemRequest = BatchGetItemRequest()            val requestItems = HashMap<String, KeysAndAttributes>()     //            val tableKeys = ArrayList<Map<String, AttributeValue>>()    //            var key: MutableMap<String, AttributeValue>     //            val keyCheck = hashMapOf<String, Boolean>() //            userData.forEach {                if (keyCheck[it.userId] != true) {                    key = HashMap()                    key["Id"] = AttributeValue().withS(it.userId)                    tableKeys.add(key)                    keyCheck[it.userId] = true                }            }            requestItems[USER_TABLE] = KeysAndAttributes().withKeys(tableKeys)                .withProjectionExpression("#a, #g, #n, #p")                .withExpressionAttributeNames(mapOf("#a" to DB_USER_AGE, "#g" to DB_USER_GENDER,  "#n" to DB_USER_NAME,  "#p" to DB_USER_PICTURE))            batchGetItemRequest.withRequestItems(requestItems)            val result = client?.batchGetItem(batchGetItemRequest)!!.responses[USER_TABLE]            for (i in 0 until  result!!.size){                userData[i].userData = UserProfileData(userData[i].id, result[i][DB_USER_NAME]?.s.toString(),                    result[i][DB_USER_PICTURE]!!.bool, result[i][DB_USER_AGE]!!.n.toLong(), result[i][DB_USER_GENDER]!!.bool)            }        }    }    /** 베스트리뷰 3개 */    fun readProductBestReview(product: ProductData) {        val queryBestReview = QueryRequest()            .withTableName(REVIEW_TABLE)            .withIndexName(REVIEW_INDEX_LIKE)            .withKeyConditions(                mapOf(                    DB_REVIEW_ID to Condition()                        .withComparisonOperator(ComparisonOperator.EQ.toString())                        .withAttributeValueList(AttributeValue().withS(product.id))                )            )            .withScanIndexForward(false)            .withProjectionExpression("#d, #wish, #review, #rating, #userId, #content, #like")            .withExpressionAttributeNames(                mapOf(                    "#d" to DB_REVIEW_DATE,                    "#wish" to DB_REVIEW_WISH,                    "#review" to DB_REVIEW_COMMENT,                    "#rating" to DB_REVIEW_POINT,                    "#userId" to DB_REVIEW_USER_ID,                    "#content" to DB_REVIEW_CONTENT,                    "#like" to DB_REVIEW_LIKE                )            )            .withLimit(3)        val bestReviewData = client!!.query(queryBestReview)?.items!!        product.bestReview.clear()        bestReviewData.forEach {            product.bestReview.add(ReviewData(product.id, it[DB_REVIEW_DATE]?.n?.toLong() ?:0, it[DB_REVIEW_USER_ID]?.s.toString(),                it[DB_REVIEW_POINT]?.n?.toFloat() ?: 0f, it[DB_REVIEW_WISH]?.bool ?:false, it[DB_REVIEW_CONTENT]?.s.toString(),                it[DB_REVIEW_LIKE]?.n!!.toInt(), it[DB_REVIEW_COMMENT]?.n!!.toInt(), UserProfileData()            ))        }        //좋아요리스트 확인하기        if (bestReviewData.size != 0){            val queryBestReviewLike = QueryRequest()                .withTableName(REVIEW_TABLE)                .withIndexName(REVIEW_INDEX_LIKE)                .withKeyConditions(                    mapOf(                        DB_REVIEW_ID to Condition()                            .withComparisonOperator(ComparisonOperator.EQ.toString())                            .withAttributeValueList(AttributeValue().withS(product.id))                    )                )                .withFilterExpression("contains(LikeList, :ll)")                .withScanIndexForward(false)                .withProjectionExpression("#d")                .withExpressionAttributeNames(mapOf("#d" to DB_REVIEW_ID))                .withExpressionAttributeValues(mapOf(":ll" to AttributeValue().withS(User.id)))                .withLimit(bestReviewData.size)            val bestReviewLikeData = client!!.query(queryBestReviewLike)?.items!!            //내가 좋아요한 리뷰 체크            for (i in 0 until product.bestReview.size){                bestReviewLikeData.forEach {                    if(product.bestReview[i].id == it[DB_REVIEW_ID]?.s.toString())                        product.bestReview[i].reviewLike = true                }            }        }        readReviewUser(product.bestReview)    }    /** 내활동 데이터 가져오기 */    fun readProductAct(product: ProductData){        val key = mapOf(            DB_REVIEW_ID to Condition()                .withComparisonOperator(ComparisonOperator.EQ.toString())                .withAttributeValueList(AttributeValue().withS(product.id)),            DB_REVIEW_USER_ID to Condition()                .withComparisonOperator(ComparisonOperator.EQ.toString())                .withAttributeValueList(AttributeValue().withS(User.id)))        val queryMyAct = QueryRequest()            .withTableName(REVIEW_TABLE)            .withKeyConditions(key)            .withProjectionExpression("#review, #rating, #wish, #date, #like, #comment")            .withExpressionAttributeNames(mapOf("#review" to DB_REVIEW_CONTENT, "#rating" to DB_REVIEW_POINT, "#wish" to DB_REVIEW_WISH,                "#date" to DB_REVIEW_DATE, "#like" to DB_REVIEW_LIKE, "#comment" to DB_REVIEW_COMMENT))            .withLimit(1)        val queryMyReviewLike = QueryRequest()            .withTableName(REVIEW_TABLE)            .withKeyConditions(key)            .withFilterExpression("contains(LikeList, :ll)")            .withProjectionExpression("#d")            .withExpressionAttributeNames(mapOf("#d" to DB_REVIEW_ID))            .withExpressionAttributeValues(mapOf(":ll" to AttributeValue().withS(User.id)))            .withLimit(1)        val bestReviewLikeData = client!!.query(queryMyReviewLike)?.items!!        //내가 좋아요한 리뷰 체크        if(client!!.query(queryMyAct)?.items!!.size != 0) {            val myActData = client!!.query(queryMyAct)?.items!![0]            product.myReview.wish = myActData[DB_REVIEW_WISH]?.bool?:false            product.myReview.point = myActData[DB_REVIEW_POINT]?.n?.toFloat() ?:0f?:0f            if(myActData[DB_REVIEW_CONTENT] != null)                product.myReview.content = myActData[DB_REVIEW_CONTENT]!!.s.toString()            else                product.myReview.content = ""            product.myReview.date = myActData[DB_REVIEW_DATE]?.n?.toLong() ?:0L?:0L            product.myReview.like = myActData[DB_REVIEW_LIKE]?.n?.toInt() ?:0?:0            product.myReview.comment = myActData[DB_REVIEW_COMMENT]?.n?.toInt() ?:0?:0            product.myReview.userId = User.id            product.myReview.id = product.id            product.myReview.userData = UserProfileData(User)            if(bestReviewLikeData.size != 0)                product.myReview.reviewLike = true        }    }    /** 제품 정보 데이터 가져오기 */    fun readProductInfo(product: ProductData){        //제품 info        val keyConditions = java.util.HashMap<String, Condition>()        keyConditions[DB_TYPE] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.type))        keyConditions[DB_ID] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.id))        val queryRequest = QueryRequest()            .withTableName(PRODUCT_TABLE)            .withKeyConditions(keyConditions)            .withLimit(1)            .withProjectionExpression("#i, #g")            .withExpressionAttributeNames(mapOf("#i" to DB_INFO, "#g" to DB_GRAPH))//예약어 쓸 때 주의        val data = client?.query(queryRequest)?.items!![0]        for(i in 0 .. 9){ product.graph[i] = data["Graph"]!!.l[i].n.toInt() }        product.info["Char"] = data["Info"]!!.m["Char"]?.s.toString()        product.info["Coun"] = data["Info"]!!.m["Coun"]?.s.toString()        product.info["Ingr"] = data["Info"]!!.m["Ingr"]?.s.toString()    }    /////////////////////리뷰///////////////////    /** 리뷰 생성 및 수정 */    fun createReview(product: ProductData, rating: Float, review: String) {        val key = hashMapOf<String, AttributeValue>()        key[DB_TYPE] = AttributeValue().withS(product.type)           //hash        key[DB_ID] = AttributeValue().withS(product.id)//range        //평가        createRating(product, rating)        if(review != "") {            val updateProductData = UpdateItemRequest()                .withTableName(PRODUCT_TABLE)                .withKey(key)            updateProductData                .addAttributeUpdatesEntry(                    DB_REVIEW,                    AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(AttributeAction.ADD))            product.review++            //댓글 저장            client?.updateItem(updateProductData)        }        //리뷰 테이블 저장        //수정 하는거면 시간 그대로, 아니면 시간 값 얻어오기        if(product.myReview.date == 0L)            product.myReview.date = Util.getTrueTime().time        val updateReviewData = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(mapOf(                DB_REVIEW_ID to AttributeValue().withS(product.id),                DB_REVIEW_USER_ID to AttributeValue().withS(User.id)))            .addAttributeUpdatesEntry(                DB_REVIEW_DATE, AttributeValueUpdate().withValue(AttributeValue().withN("${product.myReview.date}")).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                DB_REVIEW_CONTENT, AttributeValueUpdate().withValue(AttributeValue().withS(review)).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                DB_REVIEW_POINT, AttributeValueUpdate().withValue(AttributeValue().withN("$rating")).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                DB_REVIEW_LIKE, AttributeValueUpdate().withValue(AttributeValue().withN("0")).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                DB_REVIEW_COMMENT, AttributeValueUpdate().withValue(AttributeValue().withN("0")).withAction(AttributeAction.PUT))        client?.updateItem(updateReviewData)        ////평가리스트 업데이트        val userKey = hashMapOf<String, AttributeValue>()        userKey[DB_USER_ID] = AttributeValue().withS(User.id)           //hash        //유저 데이터 업데이트        val updateRating = UpdateItemRequest()            .withTableName(USER_TABLE)            .withKey(userKey)        //리뷰 달았을 시        if(review != "" && product.myReview.content == "") {            updateRating                .addAttributeUpdatesEntry(                    DB_USER_REVIEW, AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(AttributeAction.ADD))        }else if(review == "" && product.myReview.content != ""){            updateRating                .addAttributeUpdatesEntry(                    DB_USER_REVIEW, AttributeValueUpdate().withValue(AttributeValue().withN("-1")).withAction(AttributeAction.ADD))        }        product.myReview.like = 0        product.myReview.comment = 0        product.myReview.userId = User.id        product.myReview.id = product.id        product.myReview.userData = UserProfileData(User)        product.myReview.content = review        product.myReview.point= rating        client?.updateItem(updateRating)    }    /** 위시 등록 */    fun createWish(product: ProductData){        val updateReviewData = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(mapOf(                DB_REVIEW_ID to AttributeValue().withS(product.id),                DB_REVIEW_USER_ID to AttributeValue().withS(User.id)))        product.myReview.wish = !product.myReview.wish        updateReviewData.addAttributeUpdatesEntry(            DB_REVIEW_WISH, AttributeValueUpdate().withValue(AttributeValue().withBOOL(product.myReview.wish)).withAction(AttributeAction.PUT))        client?.updateItem(updateReviewData)        val n =            if(product.myReview.wish)                "1"            else                "-1"        val updateProductData = UpdateItemRequest()            .withTableName(PRODUCT_TABLE)            .withKey(mapOf(                DB_TYPE to AttributeValue().withS(product.type),                DB_ID to AttributeValue().withS(product.id)))            .addAttributeUpdatesEntry(                DB_WISH, AttributeValueUpdate().withValue(AttributeValue().withN(n)).withAction(AttributeAction.ADD))        client?.updateItem(updateProductData)    }    /** 평점 등록 */    fun createRating(product: ProductData, point: Float){        //내 리뷰에 점수 업데이트        val updateReviewData = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(mapOf(                DB_REVIEW_ID to AttributeValue().withS(product.id),                DB_REVIEW_USER_ID to AttributeValue().withS(User.id)))        updateReviewData.addAttributeUpdatesEntry(            DB_REVIEW_POINT, AttributeValueUpdate().withValue(AttributeValue().withN("$point")).withAction(AttributeAction.PUT))        client?.updateItem(updateReviewData)        //점수, 평가 수, 그래프, 성별 그래프, 유저평가 리스트 업데이트        val updateProduct = UpdateItemRequest()            .withTableName(PRODUCT_TABLE)            .withKey(mapOf(DB_TYPE to AttributeValue().withS(product.type), DB_ID to AttributeValue().withS(product.id)))        val keyConditions = java.util.HashMap<String, Condition>()        keyConditions[DB_TYPE] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.type))        keyConditions[DB_ID] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.id))        val gender = if(User.gender) DB_MALEGRAPH else DB_FEMALE_GRAPH        val queryRequest = QueryRequest()            .withTableName(PRODUCT_TABLE)            .withKeyConditions(keyConditions)            .withLimit(1)            .withProjectionExpression("#t, #r, #g, #gender")            .withExpressionAttributeNames(mapOf("#t" to DB_TOTALPOINT, "#r" to DB_RATING, "#g" to DB_GRAPH, "#gender" to gender))//예약어 쓸 때 주의        val result = client?.query(queryRequest)!!.items[0]        val g = result[DB_GRAPH]!!.l        val gg = result[gender]!!.l as ArrayList        product.totalPoint = result[DB_TOTALPOINT]!!.n.toFloat() - product.myReview.point + point        if(point != 0f && product.myReview.point == 0f) { //처음 평가 함            product.rating = result[DB_RATING]!!.n.toInt() + 1            g[(point*2-1).toInt()] = AttributeValue().withN((g[(point*2-1).toInt()].n.toInt() + 1).toString())            gg[(point*2-1).toInt()] = AttributeValue().withN((gg[(point*2-1).toInt()].n.toInt() + 1).toString())        }        else if(point == 0f && product.myReview.point != 0f) { //평가 취소함            product.rating = result[DB_RATING]!!.n.toInt() - 1            g[(product.myReview.point*2-1).toInt()] = AttributeValue().withN((g[(product.myReview.point*2-1).toInt()].n.toInt() - 1).toString())            gg[(product.myReview.point*2-1).toInt()] = AttributeValue().withN((gg[(product.myReview.point*2-1).toInt()].n.toInt() - 1).toString())        }        else{            g[(product.myReview.point*2-1).toInt()] = AttributeValue().withN((g[(product.myReview.point*2-1).toInt()].n.toInt() - 1).toString())            gg[(product.myReview.point*2-1).toInt()] = AttributeValue().withN((gg[(product.myReview.point*2-1).toInt()].n.toInt() - 1).toString())            g[(point*2-1).toInt()] = AttributeValue().withN((g[(point*2-1).toInt()].n.toInt() + 1).toString())            gg[(point*2-1).toInt()] = AttributeValue().withN((gg[(point*2-1).toInt()].n.toInt() + 1).toString())        }        if(product.rating > 0)            product.point = product.totalPoint / product.rating        else{            product.point = 0f            product.totalPoint = 0f            product.rating = 0        }        updateProduct            .addAttributeUpdatesEntry(                DB_RATING, AttributeValueUpdate().withValue(AttributeValue().withN("${product.rating}")).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                DB_TOTALPOINT, AttributeValueUpdate().withValue(AttributeValue().withN("${product.totalPoint}")).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                DB_POINT, AttributeValueUpdate().withValue(AttributeValue().withN("${product.point}")).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                DB_GRAPH, AttributeValueUpdate().withValue(AttributeValue().withL(g)).withAction(AttributeAction.PUT))            .addAttributeUpdatesEntry(                gender, AttributeValueUpdate().withValue(AttributeValue().withL(gg)).withAction(AttributeAction.PUT))        client?.updateItem(updateProduct)        //데이터 갱신        for (i in 0 .. 9) {            product.graph[i] = g[i].n.toInt()            if(User.gender) product.maleGraph[i] = gg[i].n.toInt()            else product.femaleGraph[i] = gg[i].n.toInt()        }        //제품 테이블 평가 수 카운팅        val updateProductData = UpdateItemRequest()            .withTableName(PRODUCT_TABLE)            .withKey(mapOf(DB_TYPE to AttributeValue().withS(product.type), DB_ID to AttributeValue().withS(product.id)))        if(point != 0f && product.myReview.point == 0f)            updateProductData.addAttributeUpdatesEntry(                DB_RATING, AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(AttributeAction.ADD))        else if(point == 0f && product.myReview.point > 0f)            updateProductData.addAttributeUpdatesEntry(                DB_RATING, AttributeValueUpdate().withValue(AttributeValue().withN("-1")).withAction(AttributeAction.ADD))        client?.updateItem(updateProductData)        //태그 점수 먹이기        if(point != 0f) userTagUpdate(product.tag, (point*2-1).toInt() - 4)        else userTagUpdate(product.tag, (-((product.myReview.point*2-1) - 4)).toInt())    }    /** 리뷰 업데이트 */    fun updateReviewLike(reviewData: ReviewData) {        //제품 테이블 평가 수 카운팅        val updateReviewLike = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(mapOf(DB_REVIEW_ID to AttributeValue().withS(reviewData.id), DB_REVIEW_USER_ID to AttributeValue().withS(reviewData.userId)))        reviewData.reviewLike = !reviewData.reviewLike        val action = if(reviewData.reviewLike) { //좋아요            updateReviewLike.addAttributeUpdatesEntry(                DB_REVIEW_LIKE, AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(AttributeAction.ADD))            reviewData.like++            AttributeAction.ADD        }        else { //취소            updateReviewLike.addAttributeUpdatesEntry(                DB_REVIEW_LIKE, AttributeValueUpdate().withValue(AttributeValue().withN("-1")).withAction(AttributeAction.ADD))            reviewData.like--            AttributeAction.DELETE        }        updateReviewLike            .addAttributeUpdatesEntry(                DB_REVIEW_LIKE_LIST, AttributeValueUpdate().withValue(AttributeValue().withSS(User.id)).withAction(action))        client?.updateItem(updateReviewLike)    }    /** 리뷰 삭제 */    fun deleteReview(reviewData: ReviewData, product: ProductData){        client?.updateItem(UpdateItemRequest().withTableName(REVIEW_TABLE)            .withKey(mapOf(DB_REVIEW_ID to AttributeValue().withS(reviewData.id), DB_REVIEW_USER_ID to AttributeValue().withS(reviewData.userId)))            .withAttributeUpdates(mapOf(                DB_REVIEW_LIKE  to AttributeValueUpdate().withAction(AttributeAction.DELETE),                DB_REVIEW_LIKE_LIST  to AttributeValueUpdate().withAction(AttributeAction.DELETE),                DB_REVIEW_COMMENT  to AttributeValueUpdate().withAction(AttributeAction.DELETE),                DB_REVIEW_CONTENT  to AttributeValueUpdate().withAction(AttributeAction.DELETE),                DB_REVIEW_DATE  to AttributeValueUpdate().withAction(AttributeAction.DELETE),                DB_REVIEW_COMMENT_DATA  to AttributeValueUpdate().withAction(AttributeAction.DELETE)            ))        )        client?.updateItem(UpdateItemRequest().withTableName(PRODUCT_TABLE)            .withKey(mapOf(DB_TYPE to AttributeValue().withS(product.type), DB_ID to AttributeValue().withS(reviewData.id)))            .withAttributeUpdates(mapOf(                DB_REVIEW  to AttributeValueUpdate().withAction(AttributeAction.ADD).withValue(AttributeValue().withN("-1"))            ))        )        product.review--        reviewData.removeReview()        //Like Date Content CommentData Comment    }    /** 그래프데이터 가져오기 */    fun readGraphData(product: ProductData){        val keyConditions = java.util.HashMap<String, Condition>()        keyConditions[DB_TYPE] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.type))        keyConditions[DB_ID] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.id))        val queryRequest = QueryRequest()            .withTableName(PRODUCT_TABLE)            .withKeyConditions(keyConditions)            .withLimit(1)            .withProjectionExpression("#m, #f")            .withExpressionAttributeNames(mapOf("#m" to DB_MALEGRAPH, "#f" to DB_FEMALE_GRAPH))//예약어 쓸 때 주의        val maleData = client?.query(queryRequest)?.items!![0][DB_MALEGRAPH]?.l        val femaleData = client?.query(queryRequest)?.items!![0][DB_FEMALE_GRAPH]?.l        product.graphInit()        for(point in 0 until maleData?.size!!){            val maleRating = maleData[point].n.toInt()            val femaleRating = femaleData!![point].n.toInt()            product.maleGraph[point] = maleRating            product.femaleGraph[point] = femaleRating            product.graph[point] = maleRating + femaleRating            product.male+= maleRating            product.female+= femaleRating            product.rating += maleRating + femaleRating            product.malePoint += maleRating * ((point + 1) /2)            product.femalePoint += femaleRating * ((point + 1) /2)            product.point += ((maleRating + femaleRating) * ((point + 1) /2))        }        product.malePoint /= product.male        product.femalePoint /= product.female        product.point /= product.rating    }    /** 제품 정보 가져오기 */    fun readInfoData(product: ProductData){        val keyConditions = java.util.HashMap<String, Condition>()        keyConditions[DB_TYPE] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.type))        keyConditions[DB_ID] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.id))        val queryRequest = QueryRequest()            .withTableName(PRODUCT_TABLE)            .withKeyConditions(keyConditions)            .withLimit(1)            .withProjectionExpression("#char, #coun")            .withExpressionAttributeNames(mapOf("#Char" to DB_MALEGRAPH, "#Coun" to DB_INFO))//예약어 쓸 때 주의        val maleData = client?.query(queryRequest)?.items!![0][DB_MALEGRAPH]?.l        val femaleData = client?.query(queryRequest)?.items!![0][DB_FEMALE_GRAPH]?.l        product.graphInit()        for(point in 0 until maleData?.size!!){            val maleRating = maleData[point].n.toInt()            val femaleRating = femaleData!![point].n.toInt()            product.maleGraph[point] = maleRating            product.femaleGraph[point] = femaleRating            product.graph[point] = maleRating + femaleRating            product.male+= maleRating            product.female+= femaleRating            product.rating += maleRating + femaleRating            product.malePoint += maleRating * ((point + 1) /2)            product.femalePoint += femaleRating * ((point + 1) /2)            product.point += ((maleRating + femaleRating) * ((point + 1) /2))        }        product.malePoint /= product.male        product.femalePoint /= product.female        product.point /= product.rating    }    /** 댓글 달기 */    fun createComment(review: ReviewData, comment: String) {        val t = Util.getTrueTime().time        client?.updateItem(UpdateItemRequest().withTableName(REVIEW_TABLE)            .withKey(mapOf(                DB_REVIEW_ID to AttributeValue().withS(review.id),                DB_REVIEW_USER_ID to AttributeValue().withS(review.userId)))            .withAttributeUpdates(mapOf<String, AttributeValueUpdate>(                DB_REVIEW_COMMENT_DATA to AttributeValueUpdate().withValue(AttributeValue().withL(                    AttributeValue().withM(                        mapOf<String, AttributeValue>(                            DB_REVIEW_COMMENT_ID      to (AttributeValue().withS(User.id)),                            DB_REVIEW_COMMENT_CONTENT to (AttributeValue().withS(comment)),                            DB_REVIEW_COMMENT_DATE    to (AttributeValue().withN(t.toString())),                            DB_REVIEW_COMMENT_LIKE    to (AttributeValue().withN("0"))                        )                    )                )).withAction(AttributeAction.ADD),                DB_REVIEW_COMMENT to AttributeValueUpdate()                    .withValue(AttributeValue().withN("1"))                    .withAction(AttributeAction.ADD)            ))        )        review.createComment(ReviewComment(User.id, comment, t, 0, UserProfileData(User), User.imageByte))    }    /** 댓글 가져오기 */    fun readComment(review: ReviewData): Boolean {        var addDataNames = ""        for(i in review.reviewComment.size until review.reviewComment.size + 10)            addDataNames += "CommentData[$i], "        addDataNames = addDataNames.removeRange(addDataNames.length-2 until addDataNames.length)        val comment = client?.getItem(GetItemRequest().withTableName(REVIEW_TABLE)            .withKey(mapOf(                DB_REVIEW_ID to AttributeValue().withS(review.id),                DB_REVIEW_USER_ID to AttributeValue().withS(review.userId)))            .withProjectionExpression(addDataNames)        )        comment?.item!![DB_REVIEW_COMMENT_DATA]?.l?.forEach {            review.reviewComment.add(ReviewComment(                it.m[DB_REVIEW_COMMENT_ID]?.s.toString(),                it.m[DB_REVIEW_COMMENT_CONTENT]?.s.toString(),                it.m[DB_REVIEW_COMMENT_DATE]?.n!!.toLong(),                it.m[DB_REVIEW_COMMENT_LIKE]?.n!!.toInt()            ))        }        //댓글 유저 정보        if(review.reviewComment.size !=0){            val batchGetItemRequest = BatchGetItemRequest()            val requestItems = HashMap<String, KeysAndAttributes>()     //            val tableKeys = ArrayList<Map<String, AttributeValue>>()    //            var key: MutableMap<String, AttributeValue>     //            val keyCheck = hashMapOf<String, Boolean>() //            review.reviewComment.forEach {                if (keyCheck[it.userId] != true) {                    key = HashMap()                    key["Id"] = AttributeValue().withS(it.userId)                    tableKeys.add(key)                    keyCheck[it.userId] = true                }            }            requestItems[USER_TABLE] = KeysAndAttributes().withKeys(tableKeys)                .withProjectionExpression("#a, #g, #n, #p")                .withExpressionAttributeNames(mapOf("#a" to DB_USER_AGE, "#g" to DB_USER_GENDER,  "#n" to DB_USER_NAME,  "#p" to DB_USER_PICTURE))            batchGetItemRequest.withRequestItems(requestItems)            val result = client?.batchGetItem(batchGetItemRequest)!!.responses[USER_TABLE]            for (i in 0 until  result!!.size){                for(j in 0 until review.reviewComment.size){                    if(review.reviewComment[j].userId == review.reviewComment[i].userId)                        review.reviewComment[j].userData = UserProfileData(review.reviewComment[i].userId, result[i][DB_USER_NAME]?.s.toString(),                            result[i][DB_USER_PICTURE]!!.bool, result[i][DB_USER_AGE]!!.n.toLong(), result[i][DB_USER_GENDER]!!.bool)                }            }        }        //좋아요리스트 확인하기        if (review.reviewComment.size != 0){            val start =                if(review.reviewComment.size%10 == 0)                    review.reviewComment.size - 10                else                    review.reviewComment.size - review.reviewComment.size%10            var projection = ""            for (i in start until review.reviewComment.size)                projection += "CommentData[$i].CommentLikeList.#n1, CommentData[$i].CommentDate, "            projection = projection.removeRange(projection.length-2 until projection.length)            val queryBestReviewLike = QueryRequest()                .withTableName(REVIEW_TABLE)                .withKeyConditions(                    mapOf(                        DB_REVIEW_ID to Condition()                            .withComparisonOperator(ComparisonOperator.EQ.toString())                            .withAttributeValueList(AttributeValue().withS(review.id)),                        DB_REVIEW_USER_ID to Condition()                            .withComparisonOperator(ComparisonOperator.EQ.toString())                            .withAttributeValueList(AttributeValue().withS(review.userId))                    )                )                .withProjectionExpression(projection)                .withExpressionAttributeNames(mapOf("#n1" to User.id))                .withLimit(1)            val commentLikeList = client!!.query(queryBestReviewLike)?.items?.get(0)?.get(DB_REVIEW_COMMENT_DATA)?.l!!            //내가 좋아요한 댓글 체크            if(commentLikeList.size !=0)                for (i in 0 until review.reviewComment.size){                    if(commentLikeList[i].m[DB_REVIEW_COMMENT_DATE] != null &&                        commentLikeList[i].m[DB_REVIEW_COMMENT_LIKE_LIST] != null &&                        commentLikeList[i].m[DB_REVIEW_COMMENT_LIKE_LIST]?.m?.get(User.id)?.bool!!)                        review.reviewComment[i].isLike = true                }        }        return review.reviewComment.size % 10 != 0    }    /** 댓글 좋아요 클릭 */    fun updateCommentLike(review: ReviewData, reviewData: ReviewComment, position: Int){        reviewData.isLike = !reviewData.isLike        var increase = "1"        if(reviewData.isLike){            reviewData.like++        }else{            reviewData.like--            increase = "-1"        }        //평가자 등록 및 좋아요 개수 증감        client?.updateItem(UpdateItemRequest().withTableName(REVIEW_TABLE)            .withKey(mapOf(                DB_REVIEW_ID to AttributeValue().withS(review.id),                DB_REVIEW_USER_ID to AttributeValue().withS(review.userId)))            .withUpdateExpression(                "SET CommentData[${position-1}].#n1 = :v1 ADD CommentData[${position-1}].#n2 :v2")            .withExpressionAttributeNames(mapOf(                "#n1" to DB_REVIEW_COMMENT_LIKE_LIST, "#n2" to DB_REVIEW_COMMENT_LIKE)            )            .withExpressionAttributeValues(mapOf(                ":v1" to AttributeValue().withM(mapOf(User.id to AttributeValue().withBOOL(reviewData.isLike))), ":v2" to AttributeValue().withN(increase))            )        )    }    /** 댓글 삭제 */    fun deleteCommentData(review: ReviewData, position: Int){        client?.updateItem(UpdateItemRequest().withTableName(REVIEW_TABLE)            .withKey(mapOf(                DB_REVIEW_ID to AttributeValue().withS(review.id),                DB_REVIEW_USER_ID to AttributeValue().withS(review.userId)))            .withUpdateExpression("REMOVE CommentData[${(position-1)}] ADD #v1 :v1")            .withExpressionAttributeValues(mapOf(":v1" to AttributeValue().withN("-1")))            .withExpressionAttributeNames(mapOf("#v1" to DB_REVIEW_COMMENT))        )    }    /** 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 **/    fun readSearchList(search: String){    }    /** 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 **/    //검색 태그 가져오기    fun readTagList(tag: ArrayList<String>, productData: ArrayList<ProductData>) {        var filter = ""        val value = mutableMapOf<String, AttributeValue>()        for (i in 0 until tag.size) {            filter += "contains($DB_TAG, :v$i) and "            value[":v$i"] = AttributeValue().withS(tag[i])        }        filter = filter.removeRange(filter.length - 5, filter.lastIndex + 1)        //해당 태그 제품 정보 (AND)        val product = client?.query(            QueryRequest().withTableName(PRODUCT_TABLE)                .withKeyConditions(                    mapOf(                        DB_TYPE to Condition()                            .withAttributeValueList(AttributeValue().withS(CONDOM_TYPE))                            .withComparisonOperator(ComparisonOperator.EQ)                    )                )                .withFilterExpression(filter)                .withExpressionAttributeValues(value)                .withProjectionExpression("#id, #c, #n, #t, #p, #review, #rating, #wish")                .withExpressionAttributeNames(                    mapOf(                        "#id" to DB_ID,                        "#n" to DB_NAME,                        "#c" to DB_COMPANY,                        "#t" to DB_TAG,                        "#p" to DB_POINT,                        "#rating" to DB_RATING,                        "#wish" to DB_WISH,                        "#review" to DB_REVIEW                    )                )//예약어 쓸 때 주의        )        //데이터 세팅        if (product != null && product.items.size != 0) {            product.items.forEach { productData.add(ProductData(ProductHomeList(                CONDOM_TYPE,                it[DB_ID]?.s.toString(),                it[DB_NAME]?.s.toString(),                it[DB_PICTURE]?.s.toString(),                it[DB_COMPANY]?.s.toString(),                arrayListOf(),                it[DB_POINT]?.n!!.toFloat(),                it[DB_RATING]?.n!!.toInt(),                it[DB_WISH]?.n!!.toInt(),                it[DB_REVIEW]?.n!!.toInt()            )))                productData[productData.size - 1].setTagData(it[DB_TAG]?.l!!)            }        }        for (i in 0 until productData.size){            productData[i].setTagHighlight(tag)        }    }    /////////////////////etc////////////////////////    @SuppressLint("ObsoleteSdkInt")    private fun networkThread() {        //네트워크 사용 쓰레드        if (android.os.Build.VERSION.SDK_INT > 9) {            val policy = StrictMode.ThreadPolicy.Builder().permitAll().build()            StrictMode.setThreadPolicy(policy)        }    }}