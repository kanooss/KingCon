@file:Suppress("DEPRECATION")package com.junho.app.kingcon.Etcimport android.annotation.SuppressLintimport android.content.Contextimport android.os.StrictModeimport android.util.Logimport android.widget.Toastimport com.amazonaws.AmazonServiceExceptionimport com.amazonaws.ClientConfigurationimport com.amazonaws.mobile.auth.core.internal.util.ThreadUtilsimport com.amazonaws.mobile.client.AWSMobileClientimport com.amazonaws.mobileconnectors.dynamodbv2.dynamodbmapper.DynamoDBMapperimport com.amazonaws.mobileconnectors.dynamodbv2.dynamodbmapper.DynamoDBQueryExpressionimport com.amazonaws.regions.Regionimport com.amazonaws.regions.Regionsimport com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientimport com.amazonaws.services.dynamodbv2.model.*import com.junho.app.kingcon.Etc.CallBack.CallbackAWSDBimport com.junho.app.kingcon.Etc.Retrofit.retrofitimport com.junho.app.kingcon.Etc.StringData.BEST_REVIEWimport com.junho.app.kingcon.Etc.StringData.CONDOM_MAX_NUMimport com.junho.app.kingcon.Etc.StringData.CONDOM_TYPEimport com.junho.app.kingcon.Etc.StringData.DB_COMPANYimport com.junho.app.kingcon.Etc.StringData.DB_FEMALE_GRAPHimport com.junho.app.kingcon.Etc.StringData.DB_GRAPHimport com.junho.app.kingcon.Etc.StringData.DB_IDimport com.junho.app.kingcon.Etc.StringData.DB_INFOimport com.junho.app.kingcon.Etc.StringData.DB_MALEGRAPHimport com.junho.app.kingcon.Etc.StringData.DB_NAMEimport com.junho.app.kingcon.Etc.StringData.DB_PICTUREimport com.junho.app.kingcon.Etc.StringData.DB_POINTimport com.junho.app.kingcon.Etc.StringData.DB_RATINGimport com.junho.app.kingcon.Etc.StringData.DB_REVIEWimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_CONTENTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_DATAimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_DATEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_IDimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_LIKEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_COMMENT_LIKE_LISTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_CONTENTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_DATEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_IDimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_LIKEimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_LIKE_LISTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_POINTimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_USER_IDimport com.junho.app.kingcon.Etc.StringData.DB_REVIEW_WISHimport com.junho.app.kingcon.Etc.StringData.DB_TAGimport com.junho.app.kingcon.Etc.StringData.DB_TOTALPOINTimport com.junho.app.kingcon.Etc.StringData.DB_TYPEimport com.junho.app.kingcon.Etc.StringData.DB_USER_AGEimport com.junho.app.kingcon.Etc.StringData.DB_USER_GENDERimport com.junho.app.kingcon.Etc.StringData.DB_USER_IDimport com.junho.app.kingcon.Etc.StringData.DB_USER_NAMEimport com.junho.app.kingcon.Etc.StringData.DB_USER_PICTUREimport com.junho.app.kingcon.Etc.StringData.DB_USER_PREFERTAGimport com.junho.app.kingcon.Etc.StringData.DB_USER_RATINGimport com.junho.app.kingcon.Etc.StringData.DB_USER_REVIEWimport com.junho.app.kingcon.Etc.StringData.DB_USER_WISHimport com.junho.app.kingcon.Etc.StringData.DB_WISHimport com.junho.app.kingcon.Etc.StringData.MY_REVIEWimport com.junho.app.kingcon.Etc.StringData.PRODUCT_API_KEYimport com.junho.app.kingcon.Etc.StringData.PRODUCT_INIT_NUMimport com.junho.app.kingcon.Etc.StringData.PRODUCT_TABLEimport com.junho.app.kingcon.Etc.StringData.PRODUCT_TYPEimport com.junho.app.kingcon.Etc.StringData.REVIEW_API_KEYimport com.junho.app.kingcon.Etc.StringData.REVIEW_TABLEimport com.junho.app.kingcon.Etc.StringData.REVIEW_TYPEimport com.junho.app.kingcon.Etc.StringData.SECTION_MY_REVIEWimport com.junho.app.kingcon.Etc.StringData.SECTION_PRODUCT_GRAPHimport com.junho.app.kingcon.Etc.StringData.SECTION_PRODUCT_INFOimport com.junho.app.kingcon.Etc.StringData.SECTION_PRODUCT_SERCHimport com.junho.app.kingcon.Etc.StringData.SECTION_REVIEW_BESTimport com.junho.app.kingcon.Etc.StringData.SECTION_REVIEW_COMMENTimport com.junho.app.kingcon.Etc.StringData.SECTION_REVIEW_LIKEimport com.junho.app.kingcon.Etc.StringData.SECTION_REVIEW_MOREimport com.junho.app.kingcon.Etc.StringData.SECTION_USER_DATAimport com.junho.app.kingcon.Etc.StringData.USER_API_KEYimport com.junho.app.kingcon.Etc.StringData.USER_TABLEimport com.junho.app.kingcon.Etc.StringData.USER_TYPEimport com.junho.app.kingcon.Etc.StringData.userDataimport com.junho.app.kingcon.Item.*import com.junho.app.kingcon.main.Product.View.ViewProductInfoFragmentimport io.reactivex.Observableimport io.reactivex.functions.BiFunctionimport io.reactivex.schedulers.Schedulersimport java.io.Fileimport java.io.Serializableimport java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashMapimport kotlin.concurrent.threadobject AWSDB {    private val client: AmazonDynamoDBClient by lazy {        Region.getRegion(Regions.AP_NORTHEAST_2) // CRUCIAL            .createClient(                AmazonDynamoDBClient::class.java,                AWSMobileClient.getInstance().credentialsProvider,                ClientConfiguration()            )    }    private val dynamoDBMapper: DynamoDBMapper by lazy {        DynamoDBMapper.builder()            .dynamoDBClient(client)            .awsConfiguration(AWSMobileClient.getInstance().configuration)            .build()    }    //공급자로 유저 이미 가입했는지 확인    fun isSignUp(callBack: CallbackAWSDB.Login) {        networkThread() //네트워크 사용 쓰레드        val userData = UserData()        userData.id = User.id        val queryExpression = DynamoDBQueryExpression<UserData>()            .withHashKeyValues(userData)            .withLimit(1)        val a = dynamoDBMapper.queryPage(UserData::class.java, queryExpression).results        //TODO 쿼리페이지로 1개만 가져오기 했을때 데이터 없으면 어떻게되는지 확인        when {//                아이디 서버등록 + 정보입력 둘다 안함            a.size == 0 -> callBack.isUserSignUp(id = false, info = false)//                정보입력만 안함            a[0].age == 0L -> {                User.setUser(a[0])                callBack.isUserSignUp(id = true, info = false)            }//                 둘다 함            else -> {                User.setUser(a[0])                callBack.isUserSignUp(id = true, info = true)            }        }    }    //유저 정보 저장    fun createUserBasicAttr(userData: UserData) {        thread { dynamoDBMapper.save(userData) }    }    //유저 정보 저장    fun createUserAddAttr(userData: UserProfileData) {        thread { dynamoDBMapper.save(userData) }    }    fun readUserAttr() {        thread {            val query = QueryRequest().withTableName(USER_TABLE)                .withKeyConditions(                    mapOf(                        DB_USER_ID to Condition()                            .withComparisonOperator(ComparisonOperator.EQ.toString())                            .withAttributeValueList(AttributeValue().withS(User.id))                    )                )                .withLimit(1)            client.query(query).items.forEach {                it[DB_USER_PREFERTAG]?.m?.forEach { pre ->                    User.preferTag[pre.key] = pre.value?.n?.toInt() ?: 0                }                User.name = it[DB_USER_NAME]?.s.toString()                User.age = it[DB_USER_AGE]?.n?.toLong() ?: 0                User.gender = it[DB_USER_GENDER]?.bool ?: true                User.picture = it[DB_USER_PICTURE]?.bool ?: true                User.review = it[DB_USER_REVIEW]?.n?.toInt() ?: 0                User.wish = it[DB_USER_WISH]?.n?.toInt() ?: 0                User.rating = it[DB_USER_RATING]?.n?.toInt() ?: 0            }            User.localUserDataUpdate()        }    }    fun readUserTagData() {        thread {            val data = UserPreferData()            data.id = User.id            val queryExpression = DynamoDBQueryExpression<UserPreferData>()                .withHashKeyValues(data)                .withLimit(1)                .withScanIndexForward(false)            User.setUserPreferTag(                dynamoDBMapper.queryPage(                    UserPreferData::class.java,                    queryExpression                ).results[0]            )            User.localUserDataUpdate()        }    }    fun updateUserAttr(userData: UserData) {        thread {            dynamoDBMapper.save(userData)        }    }    fun userTagUpdate(tag: ArrayList<String>, point: Int) {        User.localUserDataRead(File(userData()))        val attrName = hashMapOf<String, String>()        val attrValue = hashMapOf<String, AttributeValue>()        val tagList = HashMap<String, AttributeValue>()        var updateExpression = "SET "        var i = 1        tag.forEach {            if (User.preferTag[it] == null)                User.preferTag[it] = point            else                User.preferTag[it] = User.preferTag[it]!! + (point)            attrName["#n$i"] = it            attrValue[":m$i"] = AttributeValue().withN(User.preferTag[it].toString())            tagList[it] = AttributeValue().withN(User.preferTag[it].toString())            updateExpression += "PreferTag.#n$i = :m$i,"            i++        }        updateExpression =            updateExpression.removeRange(updateExpression.lastIndex, updateExpression.lastIndex + 1)        User.localUserDataUpdate()        //로컬 데이터 저장까진 됐고 서버에 저장하는거 낱개로        try {            //서버에 리스트 있을때            client.updateItem(                UpdateItemRequest()                    .withTableName(USER_TABLE)                    .withKey(hashMapOf("Id" to AttributeValue().withS(User.id)))                    .withUpdateExpression(updateExpression)                    .withExpressionAttributeNames(attrName)                    .withExpressionAttributeValues(attrValue)            )        } catch (e: AmazonServiceException) {            //서버에 리스트 없을떄            client.updateItem(                UpdateItemRequest()                    .withTableName(USER_TABLE)                    .withKey(hashMapOf("Id" to AttributeValue().withS(User.id)))                    .withUpdateExpression("SET PreferTag = :m1")                    .withExpressionAttributeValues(hashMapOf(":m1" to AttributeValue().withM(tagList)))            )        }    }    ///////////////////////////////////////////////    //태그 버전 체크 및 최신 데이터 가져오    fun tagVersionCheck(callBack: CallbackAWSDB.Tag) {        networkThread() //네트워크 사용 쓰레드        val tagVersion = TagVersion()        val queryExpression = DynamoDBQueryExpression<TagVersion>()            .withHashKeyValues(tagVersion)            .withLimit(1)            .withScanIndexForward(false)        //버전 데이터        AppData.loadAppData()        val newVersion =            dynamoDBMapper.queryPage(TagVersion::class.java, queryExpression).results[0].version        val oldVersion = AppData.getTagVersion()        //버전 그대로        if ((oldVersion == newVersion)) {            callBack.callbackTagData(AppData.getTagData())        }        //최신 태그 데이터 가져오기        else {            val tagData = TagData()            val query = DynamoDBQueryExpression<TagData>()                .withHashKeyValues(tagData)                .withLimit(1)                .withScanIndexForward(false)            val data = dynamoDBMapper.queryPage(TagData::class.java, query).results[0]            AppData.putTagData(data)            AppData.putTagVersion(newVersion!!)            AppData.updateAppData()            callBack.callbackTagData(data)        }    }    //////////////////////////제품데이터 생성    /** 제품데이터 저장 */    fun createProduct(context: Context, product: ProductData) {        thread {            try {                dynamoDBMapper.save(product)                ThreadUtils.runOnUiThread {                    Toast.makeText(context, "업로드 완료", Toast.LENGTH_SHORT).show()                }            } catch (e: Exception) {                Log.e("product upload error", e.toString())                ThreadUtils.runOnUiThread {                    Toast.makeText(context, "업로드 실패 $e", Toast.LENGTH_SHORT).show()                }            }        }    }    /** 제품 홈 리스트 가져오기 (랜덤 -> 추천) */    @SuppressLint("CheckResult")    fun readProduct(): ArrayList<Observable<Product>> {        //가져올 제품 랜덤으로 뽑기        val rnd = Random()        val overload = arrayListOf<Int>()        val sources = arrayListOf<Observable<Product>>()//        키값 중복 안되도록 저장        for (i in 1..PRODUCT_INIT_NUM) {            var n = (rnd.nextInt(CONDOM_MAX_NUM) + 1001)            //중복 데이터 체크            while (overload.indexOf(n) != -1)                n = (rnd.nextInt(CONDOM_MAX_NUM) + 1001)            sources                .add(                    retrofit.getProduct(                        PRODUCT_API_KEY,                        PRODUCT_TYPE,                        PRODUCT_TABLE,                        CONDOM_TYPE,                        n.toString(),                        SECTION_PRODUCT_SERCH                    ).subscribeOn(Schedulers.io())                )            overload.add(n)        }        return sources    }    /** 베스트리뷰 3개 */    @SuppressLint("CheckResult")    fun readProductBestReview(product: ProductData): Observable<Boolean>? =        retrofit            .getReview(                REVIEW_API_KEY,                REVIEW_TYPE,                REVIEW_TABLE,                product.id,                SECTION_REVIEW_BEST            )            .subscribeOn(Schedulers.io())            .filter { it.count != 0 }            .map {                //베댓  추가                product.bestReview.clear()                product.bestReview.addAll(it.items)                it            }            .flatMap {                Observable.zip(checkReviewIsLike(product.id, BEST_REVIEW, null),                    readReviewUser(it.items),                    BiFunction<Review, Array<UserData>, Boolean> { t1, t2 ->                        //베댓 좋아요 표시                        for (i in 0 until product.bestReview.size) {                            t1.items.forEach { data ->                                if (product.bestReview[i].userId == data.userId)                                    product.bestReview[i].reviewLike = true                            }                        }                        //베댓 유저 데이터                        for (i in product.bestReview.indices)                            for (j in t2.indices)                                if (product.bestReview[i].userId == t2[j].id) {                                    product.bestReview[i].userData = t2[j]                                }                        return@BiFunction true                    })            }//        if (product.bestReview.size != 0)//        checkReviewIsLike(product.id)    /** 리뷰 */    fun readProductReview(        product: ProductData,        sort: String,        lastKey: ArrayList<Map<String, String>?>    ): Observable<Boolean>? {        return retrofit            .getReviewMore(                REVIEW_API_KEY,                REVIEW_TYPE,                product.id,                sort,                lastKey[0],                SECTION_REVIEW_MORE            )            .subscribeOn(Schedulers.io())            .map {                if (lastKey[0] == null)                    product.reviews.clear()                product.reviews.addAll(it.items)                it            }            .flatMap {                Observable.zip(checkReviewIsLike(product.id, sort, lastKey[0]),                    readReviewUser(it.items),                    BiFunction<Review, Array<UserData>, Boolean> { t1, t2 ->                        MyLog.i("BEFORE_lastEvaluatedKey: "+lastKey[0].toString())                        lastKey[0] = it.lastEvaluatedKey                        it.lastEvaluatedKey.forEach{                        }                        MyLog.i("AFTER_lastEvaluatedKey: "+lastKey[0].toString())                        //베댓 좋아요 표시                        for (i in 0 until product.reviews.size) {                            t1.items.forEach { data ->                                if (product.reviews[i].userId == data.userId)                                    product.reviews[i].reviewLike = true                            }                        }                        //유저 데이터                        for (i in product.reviews.indices)                            for (j in t2.indices)                                if (product.reviews[i].userId == t2[j].id) {                                    product.reviews[i].userData = t2[j]                                }                        return@BiFunction true                    })            }//        lastKey[0] = bestReviewData.lastEvaluatedKey//        //좋아요리스트 확인하기//        if (product.reviews.size != 0) {//            checkReviewIsLike(product.id)//        }    }    /** 리뷰 좋아요(했는지 안했는지) */    @SuppressLint("CheckResult")    private fun checkReviewIsLike(        productId: String,        searchReview: String,        lastKey: Map<String, String>?    ): Observable<Review>? =        retrofit            .getReview(                REVIEW_API_KEY,                REVIEW_TYPE,                productId,                User.id,                searchReview,                lastKey,                SECTION_REVIEW_LIKE            )            .subscribeOn(Schedulers.io())    //유저 아이디 추출    private fun <T> getIdList(userData: Array<T>): String {        val keyCheck = hashMapOf<String, Boolean>()        var s = ""        userData.forEach {            val id =                when (it) {                    is ReviewData -> it.userId                    is ReviewComment -> it.userId                    else -> ""                }            if (keyCheck[id] != true) {                s += "$id,"                keyCheck[id] = true            }        }        return s.removeRange(s.length - 1, s.length)    }    /** 리뷰 올린 유저 데이터 */    @SuppressLint("CheckResult")    private fun <T> readReviewUser(userData: Array<T>): Observable<Array<UserData>>? =        //베댓 유저 정보        if (userData.size != 0) {            val s = getIdList(userData)            retrofit                .getUser(                    USER_API_KEY,                    USER_TYPE,                    USER_TABLE,                    s,                    SECTION_USER_DATA                )                .map { it.responses.array }                .subscribeOn(Schedulers.io())        } else Observable.just(arrayOf())    /** 내활동 데이터 가져오기 */    @SuppressLint("CheckResult")    fun readProductAct(product: ProductData): Observable<Unit>? {        val sources = arrayListOf<Observable<out Serializable>>()        if (product.myReviewIsNull())            sources.addAll(                arrayListOf(                    retrofit                        .getReview(                            REVIEW_API_KEY,                            REVIEW_TYPE,                            REVIEW_TABLE,                            product.id,                            User.id,                            SECTION_MY_REVIEW                        )                        .subscribeOn(Schedulers.io())                        .filter { it.count >= 1 }                        .map { it.items[0] },                    retrofit                        .getReview(                            REVIEW_API_KEY,                            REVIEW_TYPE,                            product.id,                            User.id,                            MY_REVIEW,                            null,                            SECTION_REVIEW_LIKE                        )                        .subscribeOn(Schedulers.io())                        .map { it.items }                )            )        if (product.info["Coun"] ?: "" == "")            sources.add(                retrofit                    .getProduct(                        PRODUCT_API_KEY,                        PRODUCT_TYPE,                        PRODUCT_TABLE,                        CONDOM_TYPE,                        product.id,                        SECTION_PRODUCT_INFO                    )                    .subscribeOn(Schedulers.io())                    .map { it.items[0] }            )        return Observable            .zip(sources) {                product.myReview = it[0] as ReviewData                if ((it[1] as Array<ReviewData>).size >= 1)                    product.myReview.reviewLike = true                product.info = (it[2] as ProductData).info                product.graph = (it[2] as ProductData).graph            }    }    /////////////////////리뷰///////////////////    /** 리뷰 생성 및 수정 */    fun createReview(product: ProductData, rating: Float, review: String) {        val key = hashMapOf<String, AttributeValue>()        key[DB_TYPE] = AttributeValue().withS(product.type)           //hash        key[DB_ID] = AttributeValue().withS(product.id)//range        //평가        createRating(product, rating)        if (review != "") {            val updateProductData = UpdateItemRequest()                .withTableName(PRODUCT_TABLE)                .withKey(key)                .addAttributeUpdatesEntry(                    DB_REVIEW,                    AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(                        AttributeAction.ADD                    )                )            val updateUserData = UpdateItemRequest()                .withTableName(USER_TABLE)                .withKey(mapOf(DB_USER_ID to AttributeValue().withS(User.id)))                .addAttributeUpdatesEntry(                    DB_USER_REVIEW,                    AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(                        AttributeAction.ADD                    )                )            product.review++            User.review++            User.reviewList.add(product.id)            //댓글 저장            client.updateItem(updateProductData)            client.updateItem(updateUserData)        }        //리뷰 테이블 저장        //수정 하는거면 시간 그대로, 아니면 시간 값 얻어오기        if (product.myReview.date == 0L)            product.myReview.date = Util.getTrueTime().time        val updateReviewData = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(                mapOf(                    DB_REVIEW_ID to AttributeValue().withS(product.id),                    DB_REVIEW_USER_ID to AttributeValue().withS(User.id)                )            )            .addAttributeUpdatesEntry(                DB_REVIEW_DATE,                AttributeValueUpdate().withValue(AttributeValue().withN("${product.myReview.date}")).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                DB_REVIEW_CONTENT,                AttributeValueUpdate().withValue(AttributeValue().withS(review)).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                DB_REVIEW_POINT,                AttributeValueUpdate().withValue(AttributeValue().withN("$rating")).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                DB_REVIEW_LIKE,                AttributeValueUpdate().withValue(AttributeValue().withN("0")).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                DB_REVIEW_COMMENT,                AttributeValueUpdate().withValue(AttributeValue().withN("0")).withAction(                    AttributeAction.PUT                )            )        client.updateItem(updateReviewData)        ////평가리스트 업데이트        val userKey = hashMapOf<String, AttributeValue>()        userKey[DB_USER_ID] = AttributeValue().withS(User.id)           //hash        //유저 데이터 업데이트        val updateRating = UpdateItemRequest()            .withTableName(USER_TABLE)            .withKey(userKey)        //리뷰 달았을 시        if (review != "" && product.myReview.content == "") {            updateRating                .addAttributeUpdatesEntry(                    DB_USER_REVIEW,                    AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(                        AttributeAction.ADD                    )                )        } else if (review == "" && product.myReview.content != "") {            updateRating                .addAttributeUpdatesEntry(                    DB_USER_REVIEW,                    AttributeValueUpdate().withValue(AttributeValue().withN("-1")).withAction(                        AttributeAction.ADD                    )                )        }        product.myReview.like = 0        product.myReview.comment = 0        product.myReview.userId = User.id        product.myReview.id = product.id        product.myReview.userData = UserData(User)        product.myReview.content = review        product.myReview.point = rating        client.updateItem(updateRating)        User.localUserDataUpdate()    }    /** 위시 등록 */    @SuppressLint("CheckResult")    fun createWish(product: ProductData) {        val updateReviewData = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(                mapOf(                    DB_REVIEW_ID to AttributeValue().withS(product.id),                    DB_REVIEW_USER_ID to AttributeValue().withS(User.id)                )            ).addAttributeUpdatesEntry(                DB_REVIEW_WISH,                AttributeValueUpdate().withValue(AttributeValue().withBOOL(product.myReview.wish)).withAction(                    AttributeAction.PUT                )            )        client.updateItem(updateReviewData)        product.myReview.wish = !product.myReview.wish        val n =            if (product.myReview.wish) {                User.wish++                User.wishList.add(product.id)                "1"            } else {                User.wish--                User.ratingList.remove(product.id)                "-1"            }        val updateProductData = UpdateItemRequest()            .withTableName(PRODUCT_TABLE)            .withKey(                mapOf(                    DB_TYPE to AttributeValue().withS(product.type),                    DB_ID to AttributeValue().withS(product.id)                )            )            .addAttributeUpdatesEntry(                DB_WISH,                AttributeValueUpdate().withValue(AttributeValue().withN(n)).withAction(                    AttributeAction.ADD                )            )        val updateUserData = UpdateItemRequest()            .withTableName(USER_TABLE)            .withKey(mapOf(DB_USER_ID to AttributeValue().withS(User.id)))            .addAttributeUpdatesEntry(                DB_USER_WISH,                AttributeValueUpdate().withValue(AttributeValue().withN(User.wish.toString())).withAction(                    AttributeAction.PUT                )            )        client.updateItem(updateProductData)        client.updateItem(updateUserData)        User.localUserDataUpdate()    }    /** 평점 등록 */    fun createRating(product: ProductData, point: Float) {        //내 리뷰에 점수 업데이트        val time = System.currentTimeMillis()        thread {            val updateReviewData = UpdateItemRequest()                .withTableName(REVIEW_TABLE)                .withKey(                    mapOf(                        DB_REVIEW_ID to AttributeValue().withS(product.id),                        DB_REVIEW_USER_ID to AttributeValue().withS(User.id)                    )                )            updateReviewData.addAttributeUpdatesEntry(                DB_REVIEW_POINT,                AttributeValueUpdate().withValue(AttributeValue().withN("$point")).withAction(                    AttributeAction.PUT                )            )            client.updateItem(updateReviewData)        }        thread {            //점수, 평가 수, 그래프, 성별 그래프, 유저평가 리스트 업데이트            val updateProduct = UpdateItemRequest()                .withTableName(PRODUCT_TABLE)                .withKey(                    mapOf(                        DB_TYPE to AttributeValue().withS(product.type),                        DB_ID to AttributeValue().withS(product.id)                    )                )            val keyConditions = java.util.HashMap<String, Condition>()            keyConditions[DB_TYPE] = Condition()                .withComparisonOperator(ComparisonOperator.EQ.toString())                .withAttributeValueList(AttributeValue().withS(product.type))            keyConditions[DB_ID] = Condition()                .withComparisonOperator(ComparisonOperator.EQ.toString())                .withAttributeValueList(AttributeValue().withS(product.id))            val gender = if (User.gender) DB_MALEGRAPH else DB_FEMALE_GRAPH            val queryRequest = QueryRequest()                .withTableName(PRODUCT_TABLE)                .withKeyConditions(keyConditions)                .withLimit(1)                .withProjectionExpression("#t, #r, #g, #gender")                .withExpressionAttributeNames(                    mapOf(                        "#t" to DB_TOTALPOINT,                        "#r" to DB_RATING,                        "#g" to DB_GRAPH,                        "#gender" to gender                    )                )//예약어 쓸 때 주의            val result = client.query(queryRequest)!!.items[0]            val graphData = result[DB_GRAPH]!!.l            val graphGender = result[gender]!!.l as ArrayList            product.totalPoint =                result[DB_TOTALPOINT]!!.n.toFloat() - product.myReview.point + point            if (point != 0f && product.myReview.point == 0f) { //처음 평가 함                User.rating++                User.ratingList.add(product.id)                product.rating = result[DB_RATING]!!.n.toInt() + 1                graphData[(point * 2 - 1).toInt()] =                    AttributeValue().withN((graphData[(point * 2 - 1).toInt()].n.toInt() + 1).toString())                graphGender[(point * 2 - 1).toInt()] =                    AttributeValue().withN((graphGender[(point * 2 - 1).toInt()].n.toInt() + 1).toString())            } else if (point == 0f && product.myReview.point != 0f) { //평가 취소함                product.rating = result[DB_RATING]!!.n.toInt() - 1                User.rating--                User.ratingList.remove(product.id)                graphData[(product.myReview.point * 2 - 1).toInt()] =                    AttributeValue().withN((graphData[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())                graphGender[(product.myReview.point * 2 - 1).toInt()] =                    AttributeValue().withN((graphGender[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())            } else if (point != 0f && product.myReview.point != 0f) {                graphData[(product.myReview.point * 2 - 1).toInt()] =                    AttributeValue().withN((graphData[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())                graphGender[(product.myReview.point * 2 - 1).toInt()] =                    AttributeValue().withN((graphGender[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())                graphData[(point * 2 - 1).toInt()] =                    AttributeValue().withN((graphData[(point * 2 - 1).toInt()].n.toInt() + 1).toString())                graphGender[(point * 2 - 1).toInt()] =                    AttributeValue().withN((graphGender[(point * 2 - 1).toInt()].n.toInt() + 1).toString())            }            if (product.rating > 0)                product.point = product.totalPoint / product.rating            else {                product.point = 0f                product.totalPoint = 0f                product.rating = 0            }            updateProduct                .addAttributeUpdatesEntry(                    DB_RATING,                    AttributeValueUpdate().withValue(AttributeValue().withN("${product.rating}")).withAction(                        AttributeAction.PUT                    )                )                .addAttributeUpdatesEntry(                    DB_TOTALPOINT,                    AttributeValueUpdate().withValue(AttributeValue().withN("${product.totalPoint}")).withAction(                        AttributeAction.PUT                    )                )                .addAttributeUpdatesEntry(                    DB_POINT,                    AttributeValueUpdate().withValue(AttributeValue().withN("${product.point}")).withAction(                        AttributeAction.PUT                    )                )                .addAttributeUpdatesEntry(                    DB_GRAPH,                    AttributeValueUpdate().withValue(AttributeValue().withL(graphData)).withAction(                        AttributeAction.PUT                    )                )                .addAttributeUpdatesEntry(                    gender,                    AttributeValueUpdate().withValue(AttributeValue().withL(graphGender)).withAction(                        AttributeAction.PUT                    )                )            client.updateItem(updateProduct)            //데이터 갱신            for (i in 0..9) {                product.graph[i] = graphData[i].n.toInt()                if (User.gender) product.maleGraph[i] = graphGender[i].n.toInt()                else product.femaleGraph[i] = graphGender[i].n.toInt()            }            Log.d("asdasdasd", "sadasda2222${System.currentTimeMillis() - time}")        }        thread {            val updateUserData = UpdateItemRequest()                .withTableName(USER_TABLE)                .withKey(mapOf(DB_USER_ID to AttributeValue().withS(User.id)))                .addAttributeUpdatesEntry(                    DB_USER_RATING,                    AttributeValueUpdate().withValue(AttributeValue().withN(User.rating.toString())).withAction(                        AttributeAction.PUT                    )                )            client.updateItem(updateUserData)            Log.d("asdasdasd", "sadasda4444${System.currentTimeMillis() - time}")        }        thread {            //제품 테이블 평가 수 카운팅            val updateProductData = UpdateItemRequest()                .withTableName(PRODUCT_TABLE)                .withKey(                    mapOf(                        DB_TYPE to AttributeValue().withS(product.type),                        DB_ID to AttributeValue().withS(product.id)                    )                )            if (point != 0f && product.myReview.point == 0f)                updateProductData.addAttributeUpdatesEntry(                    DB_RATING,                    AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(                        AttributeAction.ADD                    )                )            else if (point == 0f && product.myReview.point > 0f)                updateProductData.addAttributeUpdatesEntry(                    DB_RATING,                    AttributeValueUpdate().withValue(AttributeValue().withN("-1")).withAction(                        AttributeAction.ADD                    )                )            client.updateItem(updateProductData)            User.localUserDataUpdate()            //태그 점수 먹이기            if (point != 0f) userTagUpdate(product.tag, (point * 2 - 1).toInt() - 4)            else userTagUpdate(product.tag, (-((product.myReview.point * 2 - 1) - 4)).toInt())            Log.d("asdasdasd", "sadasda3333${System.currentTimeMillis() - time}")        }    }    /** 평점 등록 */    fun createRating1(product: ProductData, point: Float) {        //내 리뷰에 점수 업데이트        val time = System.currentTimeMillis()        val updateReviewData = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(                mapOf(                    DB_REVIEW_ID to AttributeValue().withS(product.id),                    DB_REVIEW_USER_ID to AttributeValue().withS(User.id)                )            )        updateReviewData.addAttributeUpdatesEntry(            DB_REVIEW_POINT,            AttributeValueUpdate().withValue(AttributeValue().withN("$point")).withAction(                AttributeAction.PUT            )        )        client.updateItem(updateReviewData)        //점수, 평가 수, 그래프, 성별 그래프, 유저평가 리스트 업데이트        val updateProduct = UpdateItemRequest()            .withTableName(PRODUCT_TABLE)            .withKey(                mapOf(                    DB_TYPE to AttributeValue().withS(product.type),                    DB_ID to AttributeValue().withS(product.id)                )            )        val keyConditions = java.util.HashMap<String, Condition>()        keyConditions[DB_TYPE] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.type))        keyConditions[DB_ID] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.id))        val gender = if (User.gender) DB_MALEGRAPH else DB_FEMALE_GRAPH        val queryRequest = QueryRequest()            .withTableName(PRODUCT_TABLE)            .withKeyConditions(keyConditions)            .withLimit(1)            .withProjectionExpression("#t, #r, #g, #gender")            .withExpressionAttributeNames(                mapOf(                    "#t" to DB_TOTALPOINT,                    "#r" to DB_RATING,                    "#g" to DB_GRAPH,                    "#gender" to gender                )            )//예약어 쓸 때 주의        val result = client.query(queryRequest)!!.items[0]        val graphData = result[DB_GRAPH]!!.l        val graphGender = result[gender]!!.l as ArrayList        product.totalPoint = result[DB_TOTALPOINT]!!.n.toFloat() - product.myReview.point + point        if (point != 0f && product.myReview.point == 0f) { //처음 평가 함            User.rating++            User.ratingList.add(product.id)            product.rating = result[DB_RATING]!!.n.toInt() + 1            graphData[(point * 2 - 1).toInt()] =                AttributeValue().withN((graphData[(point * 2 - 1).toInt()].n.toInt() + 1).toString())            graphGender[(point * 2 - 1).toInt()] =                AttributeValue().withN((graphGender[(point * 2 - 1).toInt()].n.toInt() + 1).toString())        } else if (point == 0f && product.myReview.point != 0f) { //평가 취소함            product.rating = result[DB_RATING]!!.n.toInt() - 1            User.rating--            User.ratingList.remove(product.id)            graphData[(product.myReview.point * 2 - 1).toInt()] =                AttributeValue().withN((graphData[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())            graphGender[(product.myReview.point * 2 - 1).toInt()] =                AttributeValue().withN((graphGender[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())        } else if (point != 0f && product.myReview.point != 0f) {            graphData[(product.myReview.point * 2 - 1).toInt()] =                AttributeValue().withN((graphData[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())            graphGender[(product.myReview.point * 2 - 1).toInt()] =                AttributeValue().withN((graphGender[(product.myReview.point * 2 - 1).toInt()].n.toInt() - 1).toString())            graphData[(point * 2 - 1).toInt()] =                AttributeValue().withN((graphData[(point * 2 - 1).toInt()].n.toInt() + 1).toString())            graphGender[(point * 2 - 1).toInt()] =                AttributeValue().withN((graphGender[(point * 2 - 1).toInt()].n.toInt() + 1).toString())        }        if (product.rating > 0)            product.point = product.totalPoint / product.rating        else {            product.point = 0f            product.totalPoint = 0f            product.rating = 0        }        updateProduct            .addAttributeUpdatesEntry(                DB_RATING,                AttributeValueUpdate().withValue(AttributeValue().withN("${product.rating}")).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                DB_TOTALPOINT,                AttributeValueUpdate().withValue(AttributeValue().withN("${product.totalPoint}")).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                DB_POINT,                AttributeValueUpdate().withValue(AttributeValue().withN("${product.point}")).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                DB_GRAPH,                AttributeValueUpdate().withValue(AttributeValue().withL(graphData)).withAction(                    AttributeAction.PUT                )            )            .addAttributeUpdatesEntry(                gender,                AttributeValueUpdate().withValue(AttributeValue().withL(graphGender)).withAction(                    AttributeAction.PUT                )            )        client.updateItem(updateProduct)        //데이터 갱신        for (i in 0..9) {            product.graph[i] = graphData[i].n.toInt()            if (User.gender) product.maleGraph[i] = graphGender[i].n.toInt()            else product.femaleGraph[i] = graphGender[i].n.toInt()        }        val updateUserData = UpdateItemRequest()            .withTableName(USER_TABLE)            .withKey(mapOf(DB_USER_ID to AttributeValue().withS(User.id)))            .addAttributeUpdatesEntry(                DB_USER_RATING,                AttributeValueUpdate().withValue(AttributeValue().withN(User.rating.toString())).withAction(                    AttributeAction.PUT                )            )        client.updateItem(updateUserData)        //제품 테이블 평가 수 카운팅        val updateProductData = UpdateItemRequest()            .withTableName(PRODUCT_TABLE)            .withKey(                mapOf(                    DB_TYPE to AttributeValue().withS(product.type),                    DB_ID to AttributeValue().withS(product.id)                )            )        if (point != 0f && product.myReview.point == 0f)            updateProductData.addAttributeUpdatesEntry(                DB_RATING,                AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(                    AttributeAction.ADD                )            )        else if (point == 0f && product.myReview.point > 0f)            updateProductData.addAttributeUpdatesEntry(                DB_RATING,                AttributeValueUpdate().withValue(AttributeValue().withN("-1")).withAction(                    AttributeAction.ADD                )            )        client.updateItem(updateProductData)        User.localUserDataUpdate()        //태그 점수 먹이기        if (point != 0f) userTagUpdate(product.tag, (point * 2 - 1).toInt() - 4)        else userTagUpdate(product.tag, (-((product.myReview.point * 2 - 1) - 4)).toInt())        Log.d("asdasdasd", "sadasda${System.currentTimeMillis() - time}")    }    /** 리뷰 좋아요 업데이트 */    fun updateReviewLike(reviewData: ReviewData) {        //제품 테이블 평가 수 카운팅        val updateReviewLike = UpdateItemRequest()            .withTableName(REVIEW_TABLE)            .withKey(                mapOf(                    DB_REVIEW_ID to AttributeValue().withS(reviewData.id),                    DB_REVIEW_USER_ID to AttributeValue().withS(reviewData.userId)                )            )        reviewData.reviewLike = !reviewData.reviewLike        val action = if (reviewData.reviewLike) { //좋아요            updateReviewLike.addAttributeUpdatesEntry(                DB_REVIEW_LIKE,                AttributeValueUpdate().withValue(AttributeValue().withN("1")).withAction(                    AttributeAction.ADD                )            )            reviewData.like++            AttributeAction.ADD        } else { //취소            updateReviewLike.addAttributeUpdatesEntry(                DB_REVIEW_LIKE,                AttributeValueUpdate().withValue(AttributeValue().withN("-1")).withAction(                    AttributeAction.ADD                )            )            reviewData.like--            AttributeAction.DELETE        }        updateReviewLike            .addAttributeUpdatesEntry(                DB_REVIEW_LIKE_LIST,                AttributeValueUpdate().withValue(AttributeValue().withSS(User.id)).withAction(action)            )        client.updateItem(updateReviewLike)    }    /** 리뷰 삭제 */    fun deleteReview(reviewData: ReviewData, product: ProductData) {        client.updateItem(            UpdateItemRequest().withTableName(REVIEW_TABLE)                .withKey(                    mapOf(                        DB_REVIEW_ID to AttributeValue().withS(reviewData.id),                        DB_REVIEW_USER_ID to AttributeValue().withS(reviewData.userId)                    )                )                .withAttributeUpdates(                    mapOf(                        DB_REVIEW_LIKE to AttributeValueUpdate().withAction(AttributeAction.DELETE),                        DB_REVIEW_LIKE_LIST to AttributeValueUpdate().withAction(AttributeAction.DELETE),                        DB_REVIEW_COMMENT to AttributeValueUpdate().withAction(AttributeAction.DELETE),                        DB_REVIEW_CONTENT to AttributeValueUpdate().withAction(AttributeAction.DELETE),                        DB_REVIEW_DATE to AttributeValueUpdate().withAction(AttributeAction.DELETE),                        DB_REVIEW_COMMENT_DATA to AttributeValueUpdate().withAction(AttributeAction.DELETE)                    )                )        )        val updateProductData = UpdateItemRequest().withTableName(PRODUCT_TABLE)            .withKey(                mapOf(                    DB_TYPE to AttributeValue().withS(product.type),                    DB_ID to AttributeValue().withS(reviewData.id)                )            )            .addAttributeUpdatesEntry(                DB_REVIEW,                AttributeValueUpdate().withAction(AttributeAction.ADD).withValue(                    AttributeValue().withN("-1")                )            )        val updateUserData = UpdateItemRequest()            .withTableName(USER_TABLE)            .withKey(mapOf(DB_USER_ID to AttributeValue().withS(User.id)))            .addAttributeUpdatesEntry(                DB_USER_REVIEW,                AttributeValueUpdate().withAction(AttributeAction.ADD).withValue(                    AttributeValue().withN("-1")                )            )        client.updateItem(updateProductData)        client.updateItem(updateUserData)        product.review--        User.review--        User.reviewList.remove(product.id)        reviewData.removeReview()        User.localUserDataUpdate()        //Like Date Content CommentData Comment    }    /** 그래프데이터 가져오기 */    fun readGraphData(product: ProductData): Observable<ProductData>? =        retrofit            .getProduct(                PRODUCT_API_KEY,                PRODUCT_TYPE,                PRODUCT_TABLE,                CONDOM_TYPE,                product.id,                SECTION_PRODUCT_GRAPH            )            .subscribeOn(Schedulers.io())            .flatMap {                Observable                    .range(0, 10)                    .map { i ->                        val maleRating = it.items[0].maleGraph[i]                        val femaleRating = it.items[0].femaleGraph[i]                        ViewProductInfoFragment.mainProduct.apply {                            maleGraph[i] = maleRating                            femaleGraph[i] = femaleRating                            graph[i] = maleRating + femaleRating                            male += maleRating                            female += femaleRating                            rating += maleRating + femaleRating                            if (femalePoint.isNaN()) femalePoint = 0f                            if (point.isNaN()) point = 0f                            if (malePoint.isNaN()) malePoint = 0f                            malePoint += maleRating * ((i + 1) / 2)                            femalePoint += femaleRating * ((i + 1) / 2)                            point += (maleRating + femaleRating) * ((i + 1) / 2)                        }                    }            }            .map {                ViewProductInfoFragment.mainProduct.apply {                    malePoint /= male                    femalePoint /= female                    point /= rating                }            }    /** 제품 정보 가져오기 ??안쓰는듯*/    fun readInfoData(product: ProductData) {        val keyConditions = java.util.HashMap<String, Condition>()        keyConditions[DB_TYPE] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.type))        keyConditions[DB_ID] = Condition()            .withComparisonOperator(ComparisonOperator.EQ.toString())            .withAttributeValueList(AttributeValue().withS(product.id))        val queryRequest = QueryRequest()            .withTableName(PRODUCT_TABLE)            .withKeyConditions(keyConditions)            .withLimit(1)            .withProjectionExpression("#char, #coun")            .withExpressionAttributeNames(                mapOf(                    "#Char" to DB_MALEGRAPH,                    "#Coun" to DB_INFO                )            )//예약어 쓸 때 주의        val maleData = client.query(queryRequest)?.items!![0][DB_MALEGRAPH]?.l        val femaleData = client.query(queryRequest)?.items!![0][DB_FEMALE_GRAPH]?.l        product.graphInit()        for (point in 0 until maleData?.size!!) {            val maleRating = maleData[point].n.toInt()            val femaleRating = femaleData!![point].n.toInt()            product.maleGraph[point] = maleRating            product.femaleGraph[point] = femaleRating            product.graph[point] = maleRating + femaleRating            product.male += maleRating            product.female += femaleRating            product.rating += maleRating + femaleRating            product.malePoint += maleRating * ((point + 1) / 2)            product.femalePoint += femaleRating * ((point + 1) / 2)            product.point += ((maleRating + femaleRating) * ((point + 1) / 2))        }        product.malePoint /= product.male        product.femalePoint /= product.female        product.point /= product.rating    }    /** 댓글 달기 */    fun createComment(review: ReviewData, comment: String) {        val t = Util.getTrueTime().time        client.updateItem(            UpdateItemRequest().withTableName(REVIEW_TABLE)                .withKey(                    mapOf(                        DB_REVIEW_ID to AttributeValue().withS(review.id),                        DB_REVIEW_USER_ID to AttributeValue().withS(review.userId)                    )                )                .withUpdateExpression(                    "SET $DB_REVIEW_COMMENT_DATA = list_append(if_not_exists($DB_REVIEW_COMMENT_DATA, :e1), :v1)" +                            " ADD #n1 :v2"                )                .withExpressionAttributeNames(mapOf("#n1" to DB_REVIEW_COMMENT))                .withExpressionAttributeValues(                    mapOf(                        ":v1" to AttributeValue().withL(                            AttributeValue().withM(                                mapOf<String, AttributeValue>(                                    DB_REVIEW_COMMENT_ID to (AttributeValue().withS(User.id)),                                    DB_REVIEW_COMMENT_CONTENT to (AttributeValue().withS(comment)),                                    DB_REVIEW_COMMENT_DATE to (AttributeValue().withN(t.toString())),                                    DB_REVIEW_COMMENT_LIKE to (AttributeValue().withN("0"))                                )                            )                        ), ":v2" to AttributeValue().withN("1"), ":e1" to AttributeValue().withL()                    )                )        )        review.createComment(            ReviewComment(                User.id,                comment,                t,                0,                mapOf(),                UserProfileData(User),                User.imageByte            )        )    }    /** 댓글 가져오기 */    @SuppressLint("CheckResult")    fun readComment(review: ReviewData): Observable<Any>? {        var addDataNames = ""        val max = if (10 > review.comment) 10 else review.comment        for (i in review.reviewComment.size until max)            addDataNames += "CommentData[$i].CommentLike, CommentData[$i].CommentLikeList.#n1, CommentData[$i].CommentContent, " +                    "CommentData[$i].CommentDate, CommentData[$i].CommentId, "        addDataNames = addDataNames.removeRange(addDataNames.length - 2 until addDataNames.length)        return retrofit            .getReviewComment(                REVIEW_API_KEY,                REVIEW_TYPE,                REVIEW_TABLE,                review.id,                review.userId,                User.id,                addDataNames,                SECTION_REVIEW_COMMENT            )            .subscribeOn(Schedulers.io())            .flatMap { data ->                /*Observable.zip(readCommentIsLike(review),*/                if (data.items[0].comment.isNullOrEmpty()) {                    return@flatMap Observable.just(false)                } else {                    review.reviewComment.addAll(data.items[0].comment)                    readReviewUser(arrayOf(data.items[0].comment))                        ?.map {                            for (i in review.reviewComment.indices) {                                for (j in it.indices)                                    if (review.reviewComment[i].userId == it[j].id)                                        review.reviewComment[i].userData = UserProfileData(it[j])                                if (review.reviewComment[i].likeList != null)                                    review.reviewComment[i].isLike =                                        review.reviewComment[i].likeList[User.id] ?: false                            }                            return@map Observable.just(true)                        }                }            }    }    /** 댓글 좋아요 클릭 */    fun updateCommentLike(review: ReviewData, reviewData: ReviewComment, position: Int) {        reviewData.isLike = !reviewData.isLike        var increase = "1"        if (reviewData.isLike) {            reviewData.like++        } else {            reviewData.like--            increase = "-1"        }        //평가자 등록 및 좋아요 개수 증감        client.updateItem(            UpdateItemRequest().withTableName(REVIEW_TABLE)                .withKey(                    mapOf(                        DB_REVIEW_ID to AttributeValue().withS(review.id),                        DB_REVIEW_USER_ID to AttributeValue().withS(review.userId)                    )                )                .withUpdateExpression(                    "SET CommentData[${position - 1}].#n1 = :v1 ADD CommentData[${position - 1}].#n2 :v2"                )                .withExpressionAttributeNames(                    mapOf(                        "#n1" to DB_REVIEW_COMMENT_LIKE_LIST, "#n2" to DB_REVIEW_COMMENT_LIKE                    )                )                .withExpressionAttributeValues(                    mapOf(                        ":v1" to AttributeValue().withM(                            mapOf(                                User.id to AttributeValue().withBOOL(                                    reviewData.isLike                                )                            )                        ), ":v2" to AttributeValue().withN(increase)                    )                )        )    }    /** 댓글 삭제 */    fun deleteCommentData(review: ReviewData, position: Int) {        client.updateItem(            UpdateItemRequest().withTableName(REVIEW_TABLE)                .withKey(                    mapOf(                        DB_REVIEW_ID to AttributeValue().withS(review.id),                        DB_REVIEW_USER_ID to AttributeValue().withS(review.userId)                    )                )                .withUpdateExpression("REMOVE CommentData[${(position - 1)}] ADD #v1 :v1")                .withExpressionAttributeValues(mapOf(":v1" to AttributeValue().withN("-1")))                .withExpressionAttributeNames(mapOf("#v1" to DB_REVIEW_COMMENT))        )    }    /** 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 검색 **/    fun readSearchList(search: String) {    }    /** 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 태그 **/    //검색 태그 가져오기    fun readTagList(tag: ArrayList<String>, productData: ArrayList<ProductData>) {        var filter = ""        val value = mutableMapOf<String, AttributeValue>()        for (i in 0 until tag.size) {            filter += "contains($DB_TAG, :v$i) and "            value[":v$i"] = AttributeValue().withS(tag[i])        }        filter = filter.removeRange(filter.length - 5, filter.lastIndex + 1)        //해당 태그 제품 정보 (AND)        val product = client.query(            QueryRequest().withTableName(PRODUCT_TABLE)                .withKeyConditions(                    mapOf(                        DB_TYPE to Condition()                            .withAttributeValueList(AttributeValue().withS(CONDOM_TYPE))                            .withComparisonOperator(ComparisonOperator.EQ)                    )                )                .withFilterExpression(filter)                .withExpressionAttributeValues(value)                .withProjectionExpression("#id, #c, #n, #t, #p, #review, #rating, #wish")                .withExpressionAttributeNames(                    mapOf(                        "#id" to DB_ID,                        "#n" to DB_NAME,                        "#c" to DB_COMPANY,                        "#t" to DB_TAG,                        "#p" to DB_POINT,                        "#rating" to DB_RATING,                        "#wish" to DB_WISH,                        "#review" to DB_REVIEW                    )                )//예약어 쓸 때 주의        )        //데이터 세팅        if (product != null && product.items.size != 0) {            product.items.forEach {                productData.add(                    ProductData(                        ProductHomeList(                            CONDOM_TYPE,                            it[DB_ID]?.s.toString(),                            it[DB_NAME]?.s.toString(),                            it[DB_PICTURE]?.s.toString(),                            it[DB_COMPANY]?.s.toString(),                            arrayListOf(),                            it[DB_POINT]?.n!!.toFloat(),                            it[DB_RATING]?.n!!.toInt(),                            it[DB_WISH]?.n!!.toInt(),                            it[DB_REVIEW]?.n!!.toInt()                        )                    )                )                productData[productData.size - 1].setTagData(it[DB_TAG]?.l!!)            }        }        for (i in 0 until productData.size) {            productData[i].setTagHighlight(tag)        }    }    /////////////////////etc////////////////////////    @SuppressLint("ObsoleteSdkInt")    private fun networkThread() {        //네트워크 사용 쓰레드        if (android.os.Build.VERSION.SDK_INT > 9) {            val policy = StrictMode.ThreadPolicy.Builder().permitAll().build()            StrictMode.setThreadPolicy(policy)        }    }}